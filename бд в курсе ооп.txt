Поле - это столбец
Первичный ключ - это то поле, значение которого будет уникальным  для каждой записи
Он используется для идентификации записей таблицы

Каскадное удаление - удаление, когда в подчиненных таблицах мы удаляем все связанные записи 
Аналогично каскадное обновдение данных

Связь в таблицах:
1. Один к одному
2. Один ко многим (встречается чаще всего)
3. Многие ко многим (редкий вид связи)
Для определения типа связи надо смотреть на связанные столбцы

Нормализация - процесс привидения таблик к нормальным формам
Видов НФ много, каждая последующая усиливает предыдущую

Первая норм форма- в одной ячейке одно значение(понятие одного значения определяется исходя из операций, которые будут совершаться с ячейкой).
Вторая норм форма- условия 1-ой норм формы + каждый неключевой атрибут функционально полно зависит (т.е. зависит только от него) от потенциального первичного ключа (одному значению ключа соответствует единый экземпляр значений записи).

Вся инф-ия про БД хранится в файлах
Для того, чтобы сделать некоторый запрос мы применяем язык запросов - SQL (Structed Query Language)
Этот язык является универсальным, но некоторые детали могут отличаться в зависимости от используемой СУБД

При использовании AUTO_INCREMENT нумерация при удалении не меняется (если удалим студента №4, то следующий добавленный будет иметь №5)
Строковый тип данных в БД- VARCHAR


Некоторые слова в MySQL могут быть зарезервированы (например, Group)
Один из вариантов решения - переименование

В PhpMyAdmin связи находятся в разделе Структура 

Запрос на изменение таблицы:
ALTER TABLE `имя таблицы` ADD FOREIGN KEY (`название внешнего ключа`) REFERENCES (на какое поле и где будет ссылаться) `studentGroup`(`num`) (имя табл и поле)
ON DELETE RESTRICT (не можем удалить, пока есть хотя бы одно значение в этом поле) ON UPDATE CASCADE (каскадное обновление)
ON DELETE и ON UPDATE являются дополнительными условиями
 

30/03/2023
SQL не чувствителен к регистрам, но лучше писать большими буквами 

ЗАПРОСЫ:
1.CREATE TABLE IF NOT EXISTS `название бд`.`название таблицы`(`name` <type> not null auto_increment(автонумеряция) default (значение по умолчанию) [check(нзв поля <усл>)] [primary key])
check накладывает какие-то ограничение на значения в этом поле

2.DROP TABLE `name`(удаление таблицы)

3.INSERT INTO `name table`(field1,field 2)(перечисляем поля, куда будем вставлять значения) VALUES (`1`,2)(ФОРМИРУЕТ ЗАПИСЬ, СТРОКУ!!!)

4. UPDATE `имя табл` SET  field2=4 (пара поле - значение) WHERE field1=`1`(обновляет значения в записях с этим условием)

5.DELETE FROM `имя табл` WHERE (условие) (удалить опр часть таблицы)
Если не поставить WHERE, то удалим всю таблицу

6.ALTER TABLE(ИЗМЕНЕНИЕ СТРУКТУРЫ ТАБЛИЦЫ)

7.ЗАПРОС НА ВЫБОРКУ
SELECT *(выбрать все что есть)
или
SELECT  field1,field2 FROM `имя табл` WHERE условия(выборка из опр записей) ORDER BY field1 DESC(сортировка в порядке убывания значений field1, если хочется по возр, то без DESC)
В сортировке можно указывать несколько полей (сначала по первому, потом по второму)

Агрегаты:
 count(id)...(выведет количество строк )
При запросе SELECT count(id) мы получим таблицу 1 х 1 с единственным значением - кол-во записей в таблице (avg и max по аналогии вернут таблицы)

 avg(age)...(возвращает ср. значение по полю )

 max(age)...(макс значение ) Group By gender...(получаем таблицу 2 на 1, где пол и ср. возраст пола)
Group by идет где-то близко к концу (либо перед ORDER BY, либо после)


06.04.2023
SELECT COUNT(*) FROM Студент GROUP BY группа - запрос на кол-во обучающихся в группе
SELECT группа FROM Студент WHERE фамилия LIKE 'И%' - запрос на получение групп, где есть студент с фамилией, начинающейся на И

SELECT фамилия, группа FROM студент INNER JOIN группа ON `группа`.id = `студент`.группа WHERE Year(Now())-`год поступления`=2 - запрос на получение фамилий и групп студентов второго курса

